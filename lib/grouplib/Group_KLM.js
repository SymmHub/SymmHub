import {
    iPlane,
    iSphere,
    iReflectU4,
    abs,
    sin,
    cos,
    sqrt,
    PI,
    Group,
    splaneToString,
    objectToString,
    ParamInt,
    ParamBool,
    EventProcessor, 
}
from './modules.js'

const EPSILON2 = 1.e-4;
const EPSILON = 1.e-6;
const DEBUG = true;
const MYNAME = 'Group_KLM';

/*
provides generators for reflection groups generated by 3 reflections
 */
export class Group_KLM {

    constructor() {

        this.params = {
            K: 3,
            L: 4,
            M: 3,
            s: false,
            hasR: false,
        };
        
        this.mParams = this.makeParams();
                
    }

    //
    // return map of current parameters (legacy API)
    //
    _getParamsMap() {

        var p = this.params;

        return {
            K: p.K,
            L: p.L,
            M: p.M,
            s: p.s,            
        };
    }

    setOptions(opt){
        if(opt.onChanged){
            this.onGroupChanged = opt.onChanged;
            this.eventProcessor = new EventProcessor();
            this.eventProcessor.addEventListener('onChanged', this.onGroupChanged);
        }                
    }
    
    
    getClassName(){
        return MYNAME;
    }
    
    //
    //  return external params 
    //
    getParams(){
        return this.mParams;
      
    }
        
    makeParams() {
        var par = this.params;
        var opc = this.onParamChanged.bind(this);

        return {
            s: ParamBool({
                obj: par,
                key: 's',
                name: '*',
                onChange: opc
            }),
            K:
            ParamInt({
                obj: par,
                key: 'K',
                min: 0,
                max: 20,
                onChange: opc,
            }),
            L: ParamInt({
                obj: par,
                key: 'L',
                min: 0,
                max: 20,
                onChange: opc,
            }),
            M: ParamInt({
                obj: par,
                key: 'M',
                min: 0,
                max: 20,
                onChange: opc,
            }),
            hasR: ParamBool({
                obj: par,
                key: 'hasR',
                name: 'has R',
                onChange: opc
            }),
        };
    } // makeParams
    //
    // called from UI when any group param was changed (legacy API)
    //
    onParamChanged(){
        if(DEBUG)console.log(this.constructor.name + '.onParamChanged()', 'eventProcessor:', this.eventProcessor);
        if(this.eventProcessor){
            this.eventProcessor.handleEvent({type:'onChanged', target: this});
        }    
    }

    /**
    set parameters from saved paramMap (legacy API)
     */
    _setParamsMap(paramsMap) {

        //this.controllers.K.setValue(paramsMap.K);
        //this.controllers.L.setValue(paramsMap.L);
        //this.controllers.M.setValue(paramsMap.M);

    }

    //
    //  return group description
    //
    getGroup() {
        var par = this.params;
        if(par.s) 
            return this.getGroup_sKLM();
        else 
            return this.getGroup_KLM();
    }
    
    //
    //
    //  return reflection group *KLM
    getGroup_sKLM() {

        var par = this.params;
        if (DEBUG)
            console.log('getGroup_sKLM: %d %d %d', par.K, par.L, par.M);

        var tri = this.getFD();

        var trans = [];
        var S0 = tri[0];
        var S1 = tri[1];
        var S2 = tri[2];
        
        var fd = [S0, S1, S2];
        if(DEBUG) console.log('%s fd: ', MYNAME, objectToString(fd));
        var trans = [[S0], [S1], [S2]];

        
        if(par.hasR) {
            // unit circle side 
            let Sr = iSphere([0,0,0, 1.]);
            fd.push(Sr);
            trans.push([Sr]);
        }

        let group = new Group({s: fd, t: trans});
        
        if(DEBUG) console.log('%s return: ', MYNAME, group);
        return group;

    }
    
    //
    //  return KLM group 
    // 
    getGroup_KLM() {

        var par = this.params;
        if (DEBUG)
            console.log('getGroup_KLM: %d %d %d', par.K, par.L, par.M);

        var tri = this.getFD();

        var trans = [];
        var S0 = tri[0];
        var S1 = tri[1];
        var S2 = tri[2];
        var S1a = iReflectU4(S0, S1);
        var S2a = iReflectU4(S0, S2);
        var fd = [S1, S2, S1a, S2a];

        if(DEBUG) console.log('%s fd: ', MYNAME, objectToString(fd));
        var trans = [[S1, S0], [S2, S0], [S0, S1], [S0, S2]];
        let group = new Group({s: fd, t: trans});

        if(par.hasR) {
            // unit circle side 
            let Sr = iSphere([0,0,0, 1.]);
            fd.push(Sr);
            trans.push([Sr]);
        }
        
        if(DEBUG) console.log('%s return: ', MYNAME, group);
        return group;

    }

    //
    //  return the fundamental domain
    //
    getFD() {

        var par = this.params;
        return this.makeTriangle(this.getAngle(par.K), this.getAngle(par.L), this.getAngle(par.M));

    }

    makeTriangle(a0, a1, a2) {

        if(DEBUG) console.log('%s.makeTriangle(%f,%f,%f)', MYNAME, a0/PI, a1/PI, a2/PI);
        
        if (abs(a0) < EPSILON) {
            return this.makeIdealTriangle(a0, a1, a2);
        }
        var factor = a0 + a1 + a2;

        if (DEBUG)
            console.log("Group_KLM factor: %f", factor);

        if (abs(factor - PI) < EPSILON) {
            return this.makeEuclideanTriangle(a0, a1, a2);
        } else if (factor > PI + EPSILON) {
            return this.makeSphericalTriangle(a0, a1, a2);
        } else {
            return this.makeHyperbolicTriangle(a0, a1, a2);
        }

    }

    makeEuclideanTriangle(a0, a1, a2) {

        var e = 0.25; // size of triangle
        if(DEBUG) console.log('%s.makeEuclideanTriangle(%f,%f,%f)', MYNAME, a0/PI, a1/PI, a2/PI);

        return [
            iPlane([0., -1., 0., 0.]),
            iPlane([-sin(a0), cos(a0), 0., 0.]),
            iPlane([sin(a1), cos(a1), 0., e])
        ];

    }

    makeSphericalTriangle(a0, a1, a2) {

        if(DEBUG) console.log('%s.makeSphericalTriangle(%f,%f,%f)', MYNAME, a0/PI, a1/PI, a2/PI);

        var s = []; // sides of FD
        s[0] = iPlane([0., -1., 0., 0.]);
        s[1] = iPlane([-sin(a0), cos(a0), 0., 0.]);

        var e2 = 0.25; // size of triangle

        var r = e2 * sin(a0) / (cos(a2) + cos(a1 + a0));
        var cx = r * (cos(a2) + cos(a1) * cos(a0)) / sin(a0);
        var cy = r * cos(a1);

        s[2] = iSphere([cx, cy, 0, -r]);
        return s;
    }

    makeHyperbolicTriangle(a0, a1, a2) {

        if(DEBUG) console.log('%s.makeHyperbolicTriangle(%f,%f,%f)', MYNAME, a0/PI, a1/PI, a2/PI);
        var s = [];
        s[0] = iPlane([0., -1., 0., 0.]);
        s[1] = iPlane([-sin(a0), cos(a0), 0., 0.]);

        var ax = (cos(a2) + cos(a1) * cos(a0)) / sin(a0);
        var ay = cos(a1);

        var r = 1. / sqrt(ax * ax + ay * ay - 1.);

        var cx = r * ax;
        var cy = r * ay;
        s[2] = iSphere([cx, cy, 0, -r]);

        return s;
    }

    //
    //
    //  special case with a0 = 0;
    //   we set   splane[0] = plane ((0,-1,0),0)
    //            splane[1] = sphere((-1,1,0),1)
    //            splane[2] = sphere or plane which intersect s0 and s1 with given angles
    //
    makeIdealTriangle(a0, a1, a2) {

        var s = [];
        s[0] = iPlane([0., -1., 0., 0.]);
        s[1] = iSphere([-1., 1., 0., -1.]);

        //fd.s[1] = iPlane(vec3(0.,1., 0.),2.);
        var denum = (cos(a1) + cos(a2));
        if (abs(denum) < EPSILON) {
            // vertical line
            s[2] = iSphere([0., 0., 0., 1.]);
            return s;
        }

        var r3 = 2. / denum;
        var x3 = 1.;
        var y3 = r3 * cos(a1);
        //  invert in the sphere S3 = S((-1,0), 2)
        var dd = ((x3 + 1.) * (x3 + 1.) + y3 * y3 - r3 * r3);

        if (abs(dd) > EPSILON2) {
            var a = 4. / dd;
            x3 = -1. + a * (x3 + 1.);
            y3 *= a;
            r3 *= a;
            s[2] = iSphere([x3, y3, 0, -r3]);
        } else {
            // special case when inversion center (-1,0) belong to the sphere S3
            if (abs(a2) < EPSILON) {
                // case when a1 = pi/2, a2 = 0
                s[2] = iPlane([1., 0., 0, 0.]);
            } else {
                // case when a1 = pi/4, a2 = pi/2
                s[2] = iPlane([1., 1., 0, 0.]);
            }
        }
        return s;

    } // makeIdealTriangle(a0, a1, a2)


    //
    //  convert fraction to angle
    //
    getAngle(fraction) {

        if (fraction >= 20 || fraction < 2)
            return 0;
        else
            return Math.PI / fraction;
    }

} // class Group_KLM
