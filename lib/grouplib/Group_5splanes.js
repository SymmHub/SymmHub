import {
    abs,
    sin,
    cos,
    atan2,
    sqrt,
    PI,
    TORADIANS,
    getParam,
    iPlane,
    iSphere,
    iReflectU4,
    isDefined,
    EventProcessor,
    Group, 
    ParamInt,
    ParamFloat, 
    ParamBool,
    createParamUI,
    getParamValues, 
    setParamValues, 
}
from './modules.js';

const MYNAME = 'Group_5splanes';

const DEBUG = true;

const EPSILON = 1.e-6;
const TYPE_CIRCLE = 5;
const type_LINE = 6;

//
// provides generators for reflection groups generated by 6 splanes
//
export class Group_5splanes {

    constructor() {

        this.EPSILON = 1.e-10;
        var INC = 1.e-8;

        this.params5 = {
            n13: 3,
            n23: 3,
            n14: 3,
            n24: 3,

            n35: 2,
            n45: 2,
            a3: 0,
            a4: 180,
            use_n35: false,
            use_n45: false,

            r1: 0.5,
            r2: 1,
            
            debug: false,
            uhp: true,
            s1: true,
            s2: true,
            s3: true,
            s4: true,
            s5: false,
            
        };
        this.needRecalculate = true;
        this.mParams = this.makeParams();
    }
    getClassName(){
        return MYNAME;
    }

    makeParams(){
        var par = this.params5;
        var opc = this.onParamChanged.bind(this);

        return {
            n13: ParamInt({obj:par, key:'n13', min: 0, max: 20, onChange: opc}),
            n23: ParamInt({obj:par, key:'n23', min: 0, max: 20, onChange: opc}),
            n14: ParamInt({obj:par, key:'n14', min: 0, max: 20, onChange: opc}),
            n24: ParamInt({obj:par, key:'n24', min: 0, max: 20, onChange: opc}),

            a3: ParamFloat({obj:par, key:'a3', min:-720,max:720., onChange:opc}),
            n35: ParamInt({obj:par, key:'n35', min: 0, max: 20, onChange: opc}),
            use_n35: ParamBool({obj: par, key: 'use_n35', onChange: opc}),        
            
            a4: ParamFloat({obj:par, key:'a4', min:-720,max:720., onChange:opc}),
            n45: ParamInt({obj:par, key:'n45', min: 0, max: 20, onChange: opc}),            
            use_n45: ParamBool({obj: par, key: 'use_n45', onChange: opc}),        

            r1: ParamFloat({obj:par, key:'r1', min:0.001, max:2., onChange:opc}),
            r2: ParamFloat({obj:par, key:'r2', min:0.001, max:2., onChange:opc}),                        
            uhp: ParamBool({obj: par, key: 'uhp', onChange: opc}),        

            s1: ParamBool({obj: par, key: 's1', onChange: opc}),        
            s2: ParamBool({obj: par, key: 's2', onChange: opc}),        
            s3: ParamBool({obj: par, key: 's3', onChange: opc}),        
            s4: ParamBool({obj: par, key: 's4', onChange: opc}),        
            s5: ParamBool({obj: par, key: 's5', onChange: opc}),                    
        };
    }
    
    setOptions(opt){
        if(opt.onChanged){
            this.onGroupChanged = opt.onChanged;
            this.eventProcessor = new EventProcessor();
            this.eventProcessor.addEventListener('onChanged', this.onGroupChanged);
        }                
    }

    //
    // return map of current parameters
    //
    getParamsMap() {

        return getParamValues(this.mParams);
    }

    //
    // set parameters from saved paramMap
    //
    setParamsMap(paramsMap) {
        
        setParamValues(this.mParams, paramsMap, true);

    }

    //
    //  return group description
    //
    getGroup() {
        
        // in case of reflection group we return only fundamental domain

        if(this.needRecalculate){
            this.domain = this.getFD();
            this.needRecalculate = false;
        }
        //return this.domain;
        let group = new Group({s: this.domain.s});
        return group;

    }

    //
    //
    //
    createUI(folder) {
        createParamUI(folder, this.mParams);
    }

    //
    // called from UI when any group param was changed (legacy API)
    //
    onParamChanged(){
        this.needRecalculate = true;
        if(DEBUG)console.log(this.constructor.name + '.onParamChanged()', 'eventProcessor:', this.eventProcessor);
        if(this.eventProcessor){
            this.eventProcessor.handleEvent({type:'onChanged', target: this});
        }    
    }

    //
    //  return the fundamental domain
    //
    getFD() {

        var getAngle = this.getAngle;
        var pm = this.params5;

        var a13 = getAngle(pm.n13);
        var a23 = getAngle(pm.n23);
        var a14 = getAngle(pm.n14);
        var a24 = getAngle(pm.n24);
        
        var r1 = Math.min(pm.r1, pm.r2);
        var r2 = Math.max(pm.r1, pm.r2);


        if(pm.use_n35){
            let p = getRollingSplaneParams(r1,r2,a13, a23); 
            if(p.r) {
                let a35 = getAngle(pm.n35);
                let ca = cos(a35) * (p.r/p.c);
                pm.a3 = atan2(ca, sqrt(1-ca*ca))/TORADIANS;
            } else {
                pm.a3 = 0;
            }
           this.mParams.a3.updateDisplay();
        }

        if(pm.use_n45){
           let p = getRollingSplaneParams(r1,r2,a14, a24); 
           let a45 = getAngle(pm.n45);
           if(p.r) {
               // this sphere 
               let ca = cos(a45) * (p.r/p.c);
               console.log('p: ', p, ',  ca: ', ca);
               pm.a4 = atan2(ca, -sqrt(1 - ca*ca))/TORADIANS;
           } else {               
               pm.a4 = 180;
              
           } 
           this.mParams.a4.updateDisplay();
           
        }
        
        let a3 = pm.a3 * TORADIANS;
        let a4 = pm.a4 * TORADIANS;
                                
        let s1 = iSphere([0., 0., 0., -r1]);
        let s2 = iSphere([0., 0., 0.,  r2]);               
        let s3 = getRollingSplane(r1,r2,a13, a23, a3);                    
        let s4 = getRollingSplane(r1,r2,a14, a24, a4);
        let s5 = iPlane([0., -1., 0.,  0]);               
        
                
        let s = [];
        if(pm.s1) s.push(s1);
        if(pm.s2) s.push(s2);
        if(pm.s3) s.push(s3);
        if(pm.s4) s.push(s4);
        if(pm.s5) s.push(s5);
        
                
        if (!pm.uhp) {
            // convert into Poincare ball
            var ref = iSphere([0, -1, 0, sqrt(2)]);
            for (var i = 0; i < s.length; i++) {
                s[i] = iReflectU4(ref, s[i]);
            }
        }

        return {s:s};
    }

    //
    //  convert fraction to angle
    //
    getAngle(fraction) {

        if (fraction < 2)
            return 0;
        else
            return Math.PI / fraction;
    }

} // class Group_6splanes

//
//  return params of a splane which has given angles with two concentric spheres 
//
function getRollingSplaneParams(r1, r2, a1, a2){
    
    var den = (2. * (r1 * cos(a1) + r2 * cos(a2)));    
    
    if(abs(den) > EPSILON) {
        
        let r = (r2 * r2 - r1 * r1) / den;
        let c = sqrt(r1 * r1 + 2. * r1 * r * cos(a1) + r * r);
        return {c:c, r: r};
        
    } else {
        // it is a plane 
        return {};
    }
}

//
//  return splane which has given angles with two concentric spheres 
//
function getRollingSplane(r1, r2, a1, a2, angle){
    
    var den = (2. * (r1 * cos(a1) + r2 * cos(a2)));
    
    if(abs(den) > EPSILON) {
        let r = (r2 * r2 - r1 * r1) / den;
        let c = sqrt(r1 * r1 + 2. * r1 * r * cos(a1) + r * r);
        return iSphere([c*cos(angle), c*sin(angle), 0., -r]);
    } else {
        return iPlane([cos(angle), sin(angle), 0., 0.]);
    }
}

